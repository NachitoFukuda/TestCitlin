// QuestionScreen.jsx
import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  Dimensions,
  KeyboardAvoidingView,
  Platform,
  Animated,
  ScrollView,
  SafeAreaView,
  ActivityIndicator,
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useFocusEffect, useRouter } from 'expo-router';
import KeyboardExample from '../components/questioncomp/KeyboardExample';
import HanahubukiAnimation from '../assets/lottie/Hanahubuki.json';
import NeomorphBox from '../components/ui/NeomorphBox'; // „Éã„É•„Éº„É¢„Éï„Ç£„Ç∫„É†Áî®„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà
import { Audio } from 'expo-av';
import Countdown from '@/components/questioncomp/Countdown';
import QuizEndComponent from '@/components/questioncomp/QuizEndComponent';
import DailyLimitScreen from '@/components/questioncomp/DailyLimitScreen';
import correctSound from '../assets/sound/button25.mp3'; // Ê≠£Ëß£Èü≥
import beepSound from '../assets/sound/beepSound.mp3'; // ‰∏çÊ≠£Ëß£Èü≥
import LottieView from 'lottie-react-native';
import MLabel from '@/components/questioncomp/MLabel';
import { getOrSaveImageFileUrlRTDB } from '../utils/getOrSaveImageFileUrlRTDB';
import AnimatedRemoteImage from '../components/questioncomp/AnimatedRemoteImage';
import { createEmptyCard, generatorParameters, fsrs, Rating } from 'ts-fsrs';
import useQuestionData from '../components/questioncomp/useQuestionData'; // „Éë„Çπ„ÅØÂÆüÈöõ„ÅÆÈÖçÁΩÆ„Å´Âêà„Çè„Åõ„Å¶Ë™øÊï¥
import BannerAdComponent from '@/components/indexcomp/BannerAdComponent';
import { storage } from '../firebaseConfig';
import { getDownloadURL, ref } from 'firebase/storage';
import * as Haptics from 'expo-haptics';

const { width: SCREEN_WIDTH } = Dimensions.get('window');

export default function QuestionScreen() {
  const fsrsParams = generatorParameters({ retention: 0.9, hardInterval: 1, easyBonus: 1.3 });
  const scheduler = fsrs(fsrsParams);
  // „É¶„Éº„Ç∂„ÉºÂêë„ÅëÂæ©ÁøíË©ï‰æ°„É©„Éô„É´ÔºàÊó•Êú¨Ë™ûÔºâ
  const nextButtonLabels = [
    'üò≠ÂÜçÂ≠¶Áøí',  // Again
    'üòµ‚Äçüí´Èõ£„Åó„ÅÑ',  // Hard
    'üòêÊôÆÈÄö',    // Good
    'üòçÁ∞°Âçò',    // Easy
  ];
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [filteredQuestions, setFilteredQuestions] = useState([]);
  const [score, setScore] = useState(0);
  const [userAnswer, setUserAnswer] = useState('');
  const [correctData, setCorrectData] = useState({});
  const [shuffledChoices, setShuffledChoices] = useState([]);
  const [isAnswerCorrect, setIsAnswerCorrect] = useState(null); // null: Êú™ÂõûÁ≠î, true: Ê≠£Ëß£, false: ‰∏çÊ≠£Ëß£
  const [isTransitioning, setIsTransitioning] = useState(false);
  const [isQuizFinished, setIsQuizFinished] = useState(false);
  const [displayedQuestion, setDisplayedQuestion] = useState(null);
  const [risaltQuestion, setRisaltQuestion] = useState(null);
  const [correctQuestionsList, setCorrectQuestionsList] = useState([]);
  const [showNextButton, setShowNextButton] = useState(false);
  const [showImage, setShowImage] = useState(false);
  const [imageData, setImageData] = useState(null);
  const [isDarkMode, setIsDarkMode] = useState(null);
  const [nextReviewInfo, setNextReviewInfo] = useState([]);
  const isDark = isDarkMode === true;
  const styles = createStyles(isDark);

  const { questionData, level } = useQuestionData();
  // ---- Level‚Äëaware storage keys ----
  const sanitizedLevel = String(level || 'unknown').replace(/\./g, '_');
  const STORAGE_KEY_LEVEL = `correctData_${sanitizedLevel}`;
  const FSRS_PREFIX_LEVEL = `FSRS_CARD_${sanitizedLevel}_`;
  const MAX_DAILY_LIMIT_KEY_LEVEL = `@max_daily_limit_${sanitizedLevel}`;
  const MAKE_DAYLY_COLECT = `DAYLY_CORRECT_${sanitizedLevel}`;

  // questionData„ÅåÂèñÂæó„Åï„Çå„ÅüÂæå„ÅßÂàÜÂâ≤‰ª£ÂÖ•„Åô„Çã
  const questions1 = questionData?.questions1 ?? [];
  const questions2 = questionData?.questions2 ?? [];
  const questions3 = questionData?.questions3 ?? [];


  const [isCountingDown, setIsCountingDown] = useState(false);
  const [isTodayMaxCount, setTodayMaxCount] = useState(60);
  const [dailyCount, setDailyCount] = useState(null);

  useEffect(() => {
    (async () => {
      const storedMaxCount = await AsyncStorage.getItem(MAX_DAILY_LIMIT_KEY_LEVEL);
      const today = new Date().toISOString().split('T')[0];
      let parsedMaxCount = 20;

      if (storedMaxCount) {
        try {
          const parsed = JSON.parse(storedMaxCount);
          if (parsed.date === today) {
            parsedMaxCount = parsed.value ?? 20;
          }
        } catch {
          parsedMaxCount = parseInt(storedMaxCount, 10) || 20;
        }
      }

      setTodayMaxCount(parsedMaxCount);
      const raw = await AsyncStorage.getItem(MAKE_DAYLY_COLECT);
      const parsed = raw ? JSON.parse(raw) : {};
      const todayCount = parsed[today] || 0;
      setDailyCount(todayCount);
      if (todayCount <= parsedMaxCount) {
        setIsCountingDown(true);
      } else {
        setIsCountingDown(false);
        setIsQuizFinished(true); // „ÇØ„Ç§„Ç∫„ÇíÁµÇ‰∫ÜÊâ±„ÅÑ„Å´„Åó„Å¶Âà•ÁîªÈù¢Ë°®Á§∫
      }
    })();
  }, []);

  const [C, setCount] = useState(3);
  const confettiRef = useRef(null);
  const soundRef = useRef(null);
  const fadeAnim = useRef(new Animated.Value(0)).current;

  const uniqueQuestions = useMemo(() => {
    if (!questionData) return [];
    const allQuestions = [...(questions1 || []), ...(questions2 || [])];
    const uniqueQuestionsMap = new Map();
    allQuestions.forEach((question) => {
      if (!uniqueQuestionsMap.has(question.id)) {
        uniqueQuestionsMap.set(question.id, question);
      }
    });
    const result = Array.from(uniqueQuestionsMap.values());
    return result;
  }, [questionData, questions1, questions2]);
  

  const getQuestionsBasedOnCorrectCount = useCallback((correctCount, questionId) => {
    
    let result = null;
    
    if (correctCount === 0 || correctCount === 1 || correctCount === 7) {
      result = questions1.find((q) => q.id === questionId);
    } else if ([2, 3, 5, 9].includes(correctCount)) {
      result = questions2.find((q) => q.id === questionId);
    } else if ([4, 6, 8].includes(correctCount)) {
      result = questions3.find((q) => q.id === questionId);
    } else {
      console.error(`[getQuestionsBasedOnCorrectCount] correctCount ${correctCount} „Åå„Å©„ÅÆÊù°‰ª∂„Å´„ÇÇË©≤ÂΩì„Åó„Åæ„Åõ„Çì„ÄÇ`);
    }
    return result;
  }, [questions1, questions2, questions3]);
  
  // „É©„É≥„ÉÄ„É†„Ç∑„É£„ÉÉ„Éï„É´
  const shuffleArray = useCallback((array) => {
    return array
      .map((value) => ({ value, sort: Math.random() }))
      .sort((a, b) => a.sort - b.sort)
      .map(({ value }) => value);
    }, []);

  // Ê≠£Ëß£Èü≥„Éª‰∏çÊ≠£Ëß£Èü≥„ÇíÂÜçÁîü
  const playSoundAsync = useCallback(async (sound) => {
    try {
      const { sound: playbackSound } = await Audio.Sound.createAsync(sound);
  
      return new Promise((resolve, reject) => {
        let resolved = false;
        // „Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©
        const onPlaybackStatusUpdate = (status) => {
          if (status.didJustFinish) {
            playbackSound.unloadAsync();
            if (!resolved) {
              resolved = true;
              resolve();
            }
          } else if (!status.isLoaded) {
            if (!resolved) {
              resolved = true;
              reject(new Error('Sound failed to load'));
            }
          }
        };
  
        playbackSound.setOnPlaybackStatusUpdate(onPlaybackStatusUpdate);
        // ÂÜçÁîüÈñãÂßã
        playbackSound.playAsync().catch((error) => {
          if (!resolved) {
            resolved = true;
            reject(error);
          }
        });
      });
    } catch (error) {
      console.error('[playSoundAsync] „Ç®„É©„Éº:', error);
    }
  }, []);


  useEffect(() => {
    if (uniqueQuestions.length > 0) {
      loadCorrectDataAndFilterQuestions();
    }
  }, [uniqueQuestions]);
  
  const loadCorrectDataAndFilterQuestions = async () => {
    // 1. Ê≠£Ëß£„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Åø
    const correctStored = await AsyncStorage.getItem(STORAGE_KEY_LEVEL);
    const parsedCorrectData = correctStored ? JSON.parse(correctStored) : {};
    setCorrectData(parsedCorrectData);
    console.log(parsedCorrectData)

    // 2. FSRS „Å® correctData „ÇíÁÖßÂêà„Åó„Å¶Âá∫È°åÂà§ÂÆö
    const now = new Date();
    const dueQuestions = [];
    const fsrsCards = [];
    for (const question of uniqueQuestions) {
      const qid = question.id;
      if (parsedCorrectData[qid] != null ) {
        const key = `${FSRS_PREFIX_LEVEL}${qid}`;
        const storedCard = await AsyncStorage.getItem(key);
        if (storedCard) {
          const card = JSON.parse(storedCard);
          card.due = new Date(card.due);
          fsrsCards.push({ id: qid, card });
          if (card.due <= now) {
            // CÂÄ§„Å´Âøú„Åò„Å¶ÂïèÈ°å„ÇíÂèñÂæó
            const nextQ = getQuestionsBasedOnCorrectCount(parsedCorrectData[qid].C, qid);
            if (nextQ) dueQuestions.push(nextQ);
          }
        } else {
          // FSRS „Éá„Éº„Çø„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„Ç´„Éº„Éâ„Çí‰Ωú„Çâ„Åö„Å´Âá∫È°å„ÅÆ„Åø
          const nextQ = getQuestionsBasedOnCorrectCount(0, qid);
          if (nextQ) dueQuestions.push(nextQ);
        }
      } else {
        // ÂõûÁ≠îÂ±•Ê≠¥„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„Ç´„Éº„Éâ„Çí‰Ωú„Çâ„Åö„Å´Âá∫È°å„ÅÆ„Åø
        const nextQ = getQuestionsBasedOnCorrectCount(0, qid);
        if (nextQ) dueQuestions.push(nextQ);
      }
    }
    // FSRS „Ç´„Éº„Éâ„Åã„ÇâÊ¨°Âõû„É¨„Éì„É•„ÉºÊÉÖÂ†±„ÇíË®àÁÆó„Åó„Å¶ state „Å´‰øùÂ≠ò
    const nextInfo = fsrsCards.map(({ id, card }) => {
      const diffMs = card.due.getTime() - now.getTime();
      const days = Math.ceil(diffMs / (1000 * 60 * 60 * 24));
      return { id, daysUntilDue: days };
    });
    const allKeys = await AsyncStorage.getAllKeys();
    // ‚ë° FSRS „Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÅÆ„Ç≠„Éº„Å†„ÅëÊäΩÂá∫
    const remainingFsrsKeys = allKeys.filter(key => key.startsWith(FSRS_PREFIX_LEVEL));
    // ‚ë¢ „É≠„Ç∞Âá∫Âäõ
    setNextReviewInfo(nextInfo);
    // ÊúÄÂ§ß5Âïè„Åæ„ÅßÂá∫È°å
    setFilteredQuestions(dueQuestions.slice(0, 5));
  };


  useEffect(() => {
    if (!isTransitioning && filteredQuestions.length > 0 && currentQuestionIndex < filteredQuestions.length) {
      const question = filteredQuestions[currentQuestionIndex];
      setDisplayedQuestion(question);
      setRisaltQuestion(question.question);
      loadAudio(question);
      loadImage(question);
    }
  }, [filteredQuestions, currentQuestionIndex, isTransitioning]);


  // filteredQuestions„Å®currentQuestionIndex„ÅåÂ§âÂåñ„Åó„Åü„Çâ„Ç∑„É£„ÉÉ„Éï„É´Êõ¥Êñ∞
  useEffect(() => {
    if (filteredQuestions.length > 0) {
      const current = filteredQuestions[currentQuestionIndex];
      if (!current) return;

      const currentChoices = current.choices || ['„Éá„Éï„Ç©„É´„ÉàÈÅ∏ÊäûËÇ¢1', '„Éá„Éï„Ç©„É´„ÉàÈÅ∏ÊäûËÇ¢2'];
      setShuffledChoices(shuffleArray(currentChoices));
    }
  }, [currentQuestionIndex, filteredQuestions]);

  // „Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥
  useEffect(() => {
    if (!isCountingDown) return;
  
    const interval = setInterval(() => {
      setCount((prevCount) => {
        if (prevCount > 0) {
          return prevCount - 1;
        } else {
          clearInterval(interval);
          setIsCountingDown(false);
          return prevCount; // 0 „ÅÆ„Åæ„ÅæÁ∂≠ÊåÅ
        }
      });
    }, 700);
  
    return () => clearInterval(interval); // „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
  }, [isCountingDown]);

  // Ëß£Á≠î„Çí‰øùÂ≠ò
  const saveCorrectData = useCallback(async (updatedData) => {
    try {
      await AsyncStorage.setItem(STORAGE_KEY_LEVEL, JSON.stringify(updatedData));
    } catch (error) {
    }
  }, [STORAGE_KEY_LEVEL]);

  const showCorrectAnimation = async () => {
    try {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
      setTimeout(() => {
        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      }, 300);
      await playSoundAsync(correctSound);
      playSound();
  
    } catch (error) {
      console.error('[showCorrectAnimation] „Ç®„É©„Éº:', error);
    }
  };
  
  const showCorrectAnimation1 = async () => {
    try {
      await playSoundAsync(beepSound);
    } catch (error) {
      console.error('[showCorrectAnimation1] „Ç®„É©„Éº:', error);
    }
  };
  

  // Á≠î„Åà„Çí„ÉÅ„Çß„ÉÉ„ÇØ„Åô„ÇãÈñ¢Êï∞ÂÜÖÔºàhandleAnswerÔºâ
  const handleAnswer = async (choice = null) => {
    setShowImage(true);//ÁîªÂÉèË°®Á§∫
    const currentQuestion = displayedQuestion; // state „Åã„ÇâÂèñÂæó
    if (!currentQuestion || !currentQuestion.correctAnswer) {
      return;
    }

    const Useranswer = choice !== null ? choice : userAnswer.trim();

    if (!Useranswer) {
      // ÂõûÁ≠î„ÅåÁ©∫Ê¨Ñ„ÅÆÂ†¥Âêà„ÄÅ‰∏çÊ≠£Ëß£„Å®ÂêåÊßò„ÅÆÂá¶ÁêÜ„ÇíÂÆüË°å
      await handleIncorrectAnswer(currentQuestion.id, currentQuestion.correctAnswer);
      return;
    }

    let updatedData = { ...correctData };
    let newScore = score;
    const currentCorrectCount = updatedData[currentQuestion.id]?.C || 0;
    const answer = currentQuestion.correctAnswer.trim();

    // Ë™ç„ÇÅ„ÇãË™ûÂ∞æ
    const optionalEndings = ['„Å™', '„ÅÆ', '„Åô„Çã','„Åó„Å¶','„ÅØ','„Åß„ÅÇ„Çã'];

    const candidates = [answer];

    // Ë™ûÂ∞æ„ÇíÂèñ„ÇäÈô§„ÅÑ„Åü„Éê„Éº„Ç∏„Éß„É≥„ÇíÂÄôË£ú„Å´ËøΩÂä†
    optionalEndings.forEach(ending => {
      if (answer.endsWith(ending)) {
        candidates.push(answer.slice(0, -ending.length));
      }
    });

    const isCorrect = candidates.includes(Useranswer);

    if (isCorrect) {
      // Ê≠£Ëß£„ÅÆÂ†¥Âêà
      setIsAnswerCorrect(true);
      setIsTransitioning(true);
      newScore += 1;
      setScore(newScore);
      updatedData[currentQuestion.id] = {
        C: currentCorrectCount + 1,
      };
      const shouldUpdateFSRS = !(currentCorrectCount === 0 || currentCorrectCount === 2|| currentCorrectCount === 4);
      if (shouldUpdateFSRS) {
        // FSRS„Ç´„Éº„Éâ„ÇíÊõ¥Êñ∞„Éª‰øùÂ≠ò (Ê≠£Ëß£„Å®‰ªÆÂÆö„Åó„Å¶GoodË©ï‰æ°„Çí‰ΩøÁî®)
        const fsrsKey = `${FSRS_PREFIX_LEVEL}${currentQuestion.id}`;
        // Êó¢Â≠ò„Ç´„Éº„ÉâË™≠„ÅøËæº„Åø or Êñ∞Ë¶è‰ΩúÊàê
        const storedFSRS = await AsyncStorage.getItem(fsrsKey);
        let oldCard = storedFSRS ? JSON.parse(storedFSRS) : createEmptyCard(new Date());
        // Ë©ï‰æ°„Å´Âøú„Åò„ÅüÊ¨°Âõû„Çπ„Ç±„Ç∏„É•„Éº„É´„ÇíË®àÁÆó
        const nowFSRS = new Date();
        const result = scheduler.repeat(oldCard, nowFSRS)[Rating.Good];
        const newFSRSCard = result.card;
        // ‰øùÂ≠ò
        await AsyncStorage.setItem(fsrsKey, JSON.stringify(newFSRSCard));
      }
      setCorrectData(updatedData);
      await saveCorrectData(updatedData);
      await showCorrectAnimation();
      setShowNextButton(true);
      const correctObj = {
        id: currentQuestion.id,
        question: currentQuestion.question,
        correctAnswer: currentQuestion.correctAnswer,
        japan: currentQuestion.japan,
      };
      setCorrectQuestionsList(prev =>
        prev.some(c => String(c.id) === String(correctObj.id))
          ? prev
          : [...prev, correctObj]
      );
    } else {
      //‰∏çÊ≠£Ëß£
  // ‰∏çÊ≠£Ëß£ÊôÇ„Å´FSRS„Ç´„Éº„Éâ„ÇíÊõ¥Êñ∞ (AgainË©ï‰æ°) ‚Äî Êñ∞Ë¶è„Ç´„Éº„Éâ„Å´„ÇÇÂç≥ÊôÇÂæ©Áøí„Çπ„Ç±„Ç∏„É•„Éº„É´ÁîüÊàê
  const fsrsKey = `${FSRS_PREFIX_LEVEL}${currentQuestion.id}`;
  // Êó¢Â≠ò„Ç´„Éº„ÉâË™≠„ÅøËæº„Åø or Êñ∞Ë¶è‰ΩúÊàê
  const storedFSRS = await AsyncStorage.getItem(fsrsKey);
  let oldCard = storedFSRS
    ? JSON.parse(storedFSRS)
    : createEmptyCard(new Date());
  // AgainË©ï‰æ°„ÅßÊ¨°Âõû„Çπ„Ç±„Ç∏„É•„Éº„É´„ÇíË®àÁÆó
  const nowFSRS = new Date();
  // Êñ∞Ë¶è„Ç´„Éº„Éâ„Åã„Å§‰∏çÊ≠£Ëß£„ÅÆÂ†¥Âêà„ÇÇrepeatCard„ÇíÂÆüË°å„Åó„Å¶Âç≥ÊôÇÂæ©ÁøíÁî®„Çπ„Ç±„Ç∏„É•„Éº„É´„ÇíÁîüÊàê
  const result = scheduler.repeat(oldCard, nowFSRS)[Rating.Again];
  const newFSRSCard = result.card;
  await AsyncStorage.setItem(fsrsKey, JSON.stringify(newFSRSCard));
  // Êó¢Â≠ò„ÅÆ‰∏çÊ≠£Ëß£Âá¶ÁêÜ
  await handleIncorrectAnswer(currentQuestion.id, currentQuestion.correctAnswer);
    }
  };

  // Ê≠£Ëß£ÊôÇ„Å´ Lottie „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÇíÂÜçÁîü„Åô„Çã useEffect
  useEffect(() => {
    let timeoutId;
    if (isAnswerCorrect && confettiRef.current) {
      timeoutId = setTimeout(() => {
        confettiRef.current.reset();
        confettiRef.current.play();
      }, 100);
    }
    return () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, [isAnswerCorrect]);

  
  //‰∏çÊ≠£Ëß£ÊôÇ„ÅÆÂá¶ÁêÜ
  const [missedQuestions, setMissedQuestions] = useState([]);

  const handleIncorrectAnswer = useCallback(async (questionId, correctAnswer) => {
    setIsTransitioning(true);  // Âç≥Â∫ß„Å´„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØË°®Á§∫
    let updatedData = { ...correctData };
    
    setCorrectData(updatedData);
    await saveCorrectData(updatedData);

    // ‰∏çÊ≠£Ëß£„ÉªÁ©∫ÁôΩÊôÇ„Å´missedQuestions„Å∏ËøΩÂä†
    const missedQuestionObj = {
      id: questionId,
      question: displayedQuestion?.question,
      correctAnswer: correctAnswer,
    };
    setMissedQuestions(prev => {
      if (prev.some(q => q.id === questionId)) return prev;
      return [...prev, missedQuestionObj];
    });

    setIsAnswerCorrect(false);
    setShowImage(false);
    setIsTransitioning(true);
    await showCorrectAnimation1();
    setShowNextButton(true);
  
  }, [correctData, saveCorrectData, displayedQuestion]);
  
  const timeoutRef = useRef(null);

  const handleNextQuestion = async (buttonIndex) => {
    // FSRS„Ç´„Éº„Éâ„Çí buttonIndex „Å´Âøú„Åò„ÅüË©ï‰æ°„ÅßÊõ¥Êñ∞
    const ratingMap = [Rating.Again, Rating.Hard, Rating.Good, Rating.Easy];
    const rating = ratingMap[buttonIndex - 1] ?? Rating.Good;


    // --- FSRS repeatCard (scheduling) „ÅÆÊù°‰ª∂„Çí‰øÆÊ≠£ ---
    // scheduling„ÅåÂ≠òÂú®„Åô„Çã(=ÂàùÂá∫È°å„Åß„ÅØ„Å™„ÅÑ)Â†¥Âêà„ÅÆ„ÅørepeatCard„ÇíÂÆüË°å
    const fsrsKey = `${FSRS_PREFIX_LEVEL}${displayedQuestion.id}`;
    const storedCard = await AsyncStorage.getItem(fsrsKey);
    let scheduling = null;
    if (storedCard) {
      const oldCard = JSON.parse(storedCard);
      scheduling = oldCard.scheduling;
    }
    if (rating > 1 && scheduling) {
      // repeatCardÂÆüË°å: ÂàùÂá∫È°å(=scheduling===undefined)„ÅØ„Çπ„Ç≠„ÉÉ„Éó
      const oldCard = storedCard ? JSON.parse(storedCard) : createEmptyCard(new Date());
      const fsrsResult = scheduler.repeat(oldCard, new Date())[rating];
      const newFSRSCard = fsrsResult.card;
      await AsyncStorage.setItem(fsrsKey, JSON.stringify(newFSRSCard));
    } else {
      console.log('[FSRS skipped]', {
        reason: !scheduling ? 'No scheduling data (ÂàùÂá∫È°å)' : 'Incorrect answer (rating <= 1)',
        reviewLog: { rating }
      });
    }
    await loadCorrectDataAndFilterQuestions();
    setShowImage(false)
    setShowNextButton(false);

    Animated.timing(fadeAnim, {
      toValue: 0,
      duration: 500,
      useNativeDriver: true,
    }).start(() => {

      setUserAnswer('');
      setIsAnswerCorrect(null);
      if (currentQuestionIndex < filteredQuestions.length - 1) {
        const nextIndex = currentQuestionIndex + 1;
        setCurrentQuestionIndex(nextIndex);
        const nextQ = filteredQuestions+1[nextIndex];
        // „Éï„Çß„Éº„Éâ„Ç¢„Ç¶„ÉàÂæå„ÄÅ„Éï„Çß„Éº„Éâ„Ç§„É≥Ââç„Å´ UI ‰∏ä„ÅÆÂïèÈ°å„ÇíÂàá„ÇäÊõø„Åà„Çã
        setDisplayedQuestion(nextQ);
        // „Éï„Çß„Éº„Éâ„Ç§„É≥Ââç„Å´ UI ‰∏ä„ÅÆÂïèÈ°åË°®Á§∫„Å´Âàá„ÇäÊõø„Åà
        setIsTransitioning(false);

        loadAudio(nextQ);
        loadImage(nextQ);
      } else {
        setIsQuizFinished(true);
      }
      // „Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØÁä∂ÊÖã„ÇíËß£Èô§
      // „Çø„Ç§„Éû„Éº„ÅÆID„Çí‰øùÂ≠ò„Åó„ÄÅ„Éï„Çß„Éº„Éâ„Ç§„É≥ÈñãÂßã
      timeoutRef.current = setTimeout(() => {
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 500,
          useNativeDriver: true,
        }).start(() => {
          setIsTransitioning(false);
        });
      }, 100);
    });
  };
  
  // „Ç¢„É≥„Éû„Ç¶„É≥„ÉàÊôÇ„Å´„Çø„Ç§„Éû„Éº„Çí„Ç≠„É£„É≥„Çª„É´
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);
  

  const animatedStyles = {
    opacity: fadeAnim,
    transform: [
      {
        translateY: fadeAnim.interpolate({
          inputRange: [0, 1],
          outputRange: [0, 0],
        }),
      },
    ],
  };

  // „Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÅÆ„Ç¢„É≥„Éû„Ç¶„É≥„ÉàÊôÇ„Å´soundRef„ÇíËß£Êîæ„Åô„ÇãÂá¶ÁêÜ
  useEffect(() => {
    return () => {
      if (soundRef.current) {
        soundRef.current.unloadAsync();
        soundRef.current = null;
      }
    };
  }, []);

  useEffect(() => {
    let animation;
    if (displayedQuestion) {
      animation = Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 500,
        useNativeDriver: true,
      });
      animation.start();
    }
    return () => {
      if (animation) {
        animation.stop(); // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÇíÂÅúÊ≠¢„Åó„Å¶„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
      }
    };
  }, [displayedQuestion, fadeAnim]);

  useEffect(() => {
    if (correctCount === 2 || correctCount === 7) {
      // „Éï„Çß„Éº„Éâ„Ç§„É≥„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÇíÈñãÂßã
      Animated.timing(fadeAnim, {
        toValue: 1, // ÂÆåÂÖ®„Å´Ë°®Á§∫
        duration: 500, // 500ms„Åß„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
        useNativeDriver: true, // „Éç„Ç§„ÉÜ„Ç£„Éñ„Éâ„É©„Ç§„Éê„Éº„Çí‰ΩøÁî®
      }).start();
    } else {
      // „Éï„Çß„Éº„Éâ„Ç¢„Ç¶„ÉàÔºàÂøÖË¶Å„Å™„ÇâËøΩÂä†Ôºâ
      Animated.timing(fadeAnim, {
        toValue: 0, // ÈùûË°®Á§∫
        duration: 500,
        useNativeDriver: true,
      }).start();
    }
  }, [correctCount]);

  // „Ç≠„Éº„Éú„Éº„ÉâÂÖ•Âäõ
  const handleKeyPress = (key) => {
    if (key === 'backspace') {
      setUserAnswer((prev) => prev.slice(0, -1));
    } else if (key === 'submit') {
      handleAnswer();
    } else {
      setUserAnswer((prev) => prev + key);
    }
  };

  const [loadedSound, setLoadedSound] = useState(null);
  const [reloading, setReloading] = useState(false);
  const [queuedPlay, setQueuedPlay] = useState(false);


    // üñºÔ∏è ÁîªÂÉèË™≠„ÅøËæº„ÅøÂá¶ÁêÜ
    const loadImage = async (question) => {
      try {
        // ‰æã: „É¨„Éô„É´ÔºãID „Çí„Ç≠„Éº„Å´„Åó„Åü„ÅÑ„Å™„Çâ
        let currentLevel = level || "3";
        // „Éâ„ÉÉ„Éà„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åü„Çâ„Ç¢„É≥„ÉÄ„Éº„Çπ„Ç≥„Ç¢„Å´ÁΩÆÊèõ
        if (currentLevel.includes('.')) {
          currentLevel = currentLevel.replace(/\./g, '_');
        }    
        const imageKey = `${currentLevel}-${question.id}`;
        // getOrSaveImageUrlRTDB „ÅÆÊàª„ÇäÂÄ§„ÇíÂèó„ÅëÂèñ„Çã
        const url = await getOrSaveImageFileUrlRTDB(imageKey, question.question);
        if (url) {
          // state „Å´„Çª„ÉÉ„Éà„Åó„Å¶ÁîªÈù¢„Å´ÂèçÊò†
          setImageData({
            src: { large: url },
            photographer: 'Unknown',  // „ÇÇ„ÅóDB„Å´photographerÊÉÖÂ†±„ÅåÂÖ•„Å£„Å¶„ÅÑ„Çå„Å∞‰Ωø„ÅÜ
          });
        } else {
          console.warn('ÁîªÂÉèURL„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
          setImageData(null);
        }
      } catch (error) {
        setImageData(null);
      }
    };
    
  // üîä Èü≥Â£∞Ë™≠„ÅøËæº„ÅøÂá¶ÁêÜ
  const loadAudio = async (question) => {
    setReloading(true);
    try {
      if (loadedSound) {
        await loadedSound.unloadAsync();
        setLoadedSound(null);
      }
      // ‚ë† ÂÖÉ„ÅÆ„É¨„Éô„É´ÊñáÂ≠óÂàó„Çí„Åù„ÅÆ„Åæ„ÅæÂèñÂæóÔºà„Éâ„ÉÉ„Éà„ÇÇ„Ç¢„É≥„ÉÄ„Éº„Çπ„Ç≥„Ç¢„ÇÇÂ§âÊèõ„Åó„Å™„ÅÑÔºâ
      const folder = level || "3";  // ‰æã: "1.5"
      // ‚ë° „Åù„ÅÆ„Åæ„Åæ„Éë„Çπ„ÇíÁµÑ„ÅøÁ´ã„Å¶
      const filePath = `${folder}/${question.id}.mp3`;  // => "1.5/2.mp3"
      // ‚ë¢ „ÉÄ„Ç¶„É≥„É≠„Éº„ÉâURL„ÇíÂèñÂæó
      const soundUrl = await getDownloadURL(ref(storage, filePath));
      // ‚ë£ Audio „Çí„É≠„Éº„ÉâÔºÜÊ∫ñÂÇô
      const source = { uri: soundUrl };
      const sound = new Audio.Sound();
      await sound.loadAsync(source, { shouldPlay: false }, true);
      await new Promise(resolve => setTimeout(resolve, 100));
      const status = await sound.getStatusAsync();
      if (!status.isLoaded || !status.durationMillis) {
        throw new Error('Sound failed to load properly');
      }
      setLoadedSound(sound);
    } catch (error) {
      setLoadedSound(null);
    }
    setReloading(false);
  };
  
  
  const [isLoading, setIsLoading] = useState(false);

  // Èü≥Â£∞ÂÜçÁîü„Éú„Çø„É≥„ÅßÂëº„Å≥Âá∫„ÅôÈñ¢Êï∞
  const playSound = async () => {    // „ÇÇ„Åó„Åæ„Å†„É™„É≠„Éº„Éâ‰∏≠„Åæ„Åü„ÅØÈü≥Â£∞„Åå„É≠„Éº„Éâ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅ
    setIsLoading(true);    
    if (reloading || !loadedSound) {
      setIsLoading(false); // „Ç≠„É•„Éº„Å∏ÁôªÈå≤„Åó„Åü„Çâ„É≠„Éº„Éá„Ç£„É≥„Ç∞Áä∂ÊÖã„ÇíËß£Èô§
      setQueuedPlay(true);
      return;
    }
    try {
      // ÂÖàÈ†≠„Å´ÂÜçÁîü‰ΩçÁΩÆ„Çí„É™„Çª„ÉÉ„Éà„Åó„Å¶„Åã„ÇâÂÜçÁîü
      await loadedSound.setPositionAsync(0);
      await loadedSound.playAsync();
      setIsLoading(false);
    } catch (error) {
      console.error('Èü≥Â£∞ÂÜçÁîü„Ç®„É©„Éº:', error);
    }
  };

  // reloading „ÅåÁµÇ‰∫Ü„Åó„Åü„Çø„Ç§„Éü„É≥„Ç∞„Åß„ÄÅ„ÇÇ„Åó queuedPlay „Åå true „Å™„ÇâÂÜçÁîü„ÇíËá™Âãï„ÅßÂÆüË°å
  useEffect(() => {
    if (!reloading && queuedPlay && loadedSound) {
      playSound();
      setQueuedPlay(false);
    }
  }, [reloading, queuedPlay, loadedSound]);


  // „Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥ÁîªÈù¢
  if (isCountingDown) {
    return (
        <Countdown 
          count={C}
        />
    );
  }

  // Êó•Ê¨°‰∏äÈôêÁîªÈù¢„ÅÆË°®Á§∫
  //  if (isTodayMaxCount) {
  //   return <DailyLimitScreen level={3}/>;
  //    }

  // Âá∫È°åÊï∞0
  if (filteredQuestions.length === 0) {
    return (
      <View style={styles.container}>
      </View>
    );
  }

  // „ÇØ„Ç§„Ç∫ÁµÇ‰∫ÜÊôÇ„Å´Ê≠£Ëß£„Éª‰∏çÊ≠£Ëß£ÂïèÈ°å„ÇíÂàÜÈ°û„Åó„Å¶„É¨„Éì„É•„ÉºÁîªÈù¢„Å∏
  if (isQuizFinished) {
    // Ê≠£Ëß£„É™„Çπ„Éà„ÅØ state „Åã„Çâ
    const correctQuestions = correctQuestionsList;
    // ‰∏çÊ≠£Ëß£„ÅØÊó¢Â≠ò„ÅÆ missedQuestions „Åã„Çâ
    const incorrectQuestions = missedQuestions.map(m => ({
      id: m.id,
      question: m.question,
      correctAnswer: m.correctAnswer,
      japan: m.japan,
    }));

    return (
      <QuizEndComponent
        score={score}
        total={filteredQuestions.length}
        nextReviewInfo={nextReviewInfo}
        correctQuestions={correctQuestions} 
        incorrectQuestions={incorrectQuestions}
        visibleCount={filteredQuestions.length}
        themeColors={{ textColor: '#666' }}
      />
    );
  }

  // displayedQuestion „ÅåÊú™Ë®≠ÂÆö„Å™„Çâ„É≠„Éº„Éá„Ç£„É≥„Ç∞Ë°®Á§∫
  if (!displayedQuestion) {
    return (
      <View style={styles.container}>
        <ActivityIndicator size="large" color="#000" />
      </View>
    );
  }
  // ÁèæÂú®„ÅÆÂïèÈ°å (using displayedQuestion from state)
  const currentQuestion = displayedQuestion;
  const correctCount = correctData[currentQuestion.id]?.C || 0;
  // 1, 3, 5 „ÅÆÂ†¥Âêà„ÅØ FSRS „ÇíÊõ¥Êñ∞„Åó„Å™„ÅÑ
  const shouldUpdateFSRS = !(correctCount === 0 || correctCount === 2 || correctCount === 4);
  // ÂâçÂõûÊ≠£Ëß£„Åã„Çâ„ÅÆÁµåÈÅéÊôÇÈñì
  const L = correctData[currentQuestion.id]?.L
    ? new Date(correctData[currentQuestion.id].L)
    : null;
  const showKeyboardExample = [3, 4, 5, 6, 8, 9].includes(correctCount);
  return (
    <KeyboardAvoidingView
      style={styles.keyboardAvoidingView}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 0 : 0}
    >
      {/* 
        ScrollView 1„Å§„Å†„Åë„ÅßÁîªÈù¢ÂÖ®‰Ωì„Çí„Çπ„ÇØ„É≠„Éº„É´ 
      */}
      <ScrollView
        style={{ flex: 1 }}
        contentContainerStyle={{
          flexGrow: 1,
          alignItems: 'center',
          paddingBottom: 0,
        }}
      >

          {isTransitioning ? (
              <>
                {isAnswerCorrect === true && (
                  <View style={styles.greenBar}></View>
                )}
                {isAnswerCorrect === false && (
                  <View style={styles.redBar}></View>
                )}
              </>
          ) : (
              <View style={styles.nullBar}></View>
          )}

      <View style={styles.container}>

      <View style={styles.Adcontainer}>
          <BannerAdComponent />
      </View>

      <View style={styles.mLabelContainer}>
          <MLabel
            mValue={correctData[currentQuestion.id]?.M}
            questionId={currentQuestion.id}
          />
        </View>

        {/* ÂïèÈ°å„ÉªËß£Á≠î„Å™„Å© */}
        <NeomorphBox
          width={SCREEN_WIDTH * 0.85}
          height={150} // isTransitioning „ÅÆÊù°‰ª∂„ÅåÂêå„ÅòÈ´ò„Åï„ÅÆÂ†¥Âêà„ÅØÂõ∫ÂÆö„Åß„ÇÇÂïèÈ°å„ÅÇ„Çä„Åæ„Åõ„Çì
          style={styles.neomorphBox}
        >
          <Animated.View style={[animatedStyles, { width: '100%', alignItems: 'center' }]}>
            {/* Âè≥‰∏ä„Å´ M „ÅÆ„É©„Éô„É´„ÇíË°®Á§∫ */}
            <View style={styles.questionSection}>
              {!isTransitioning ? (
                <>
                  {/* ÂíåË®≥ */}
                  {(correctCount === 4 || correctCount === 6|| correctCount === 8) && (
                    <Text style={styles.translationText}>
                      ÂíåË®≥: {currentQuestion.japan || 'ÂíåË®≥„Å™„Åó'}
                    </Text>
                  )}
                  {/* ÂïèÈ°åÊñá */}
                  {correctCount !== 5 && (
                    <Text style={styles.questionText}>
                      {currentQuestion.question}
                    </Text>
                  )}
                  {/* Èü≥Â£∞ÂÜçÁîü„Éú„Çø„É≥ÔºàcorrectCount===5Ôºâ */}
                  {correctCount === 5 && (
                    <TouchableOpacity
                    onPress={playSound}
                    accessibilityLabel="Èü≥Â£∞ÂÜçÁîü„Éú„Çø„É≥"
                    accessibilityHint="„Çø„ÉÉ„Éó„Åô„Çã„Å®ËÅû„Åì„Åà„ÅüÂçòË™û„ÅÆÈü≥Â£∞„ÅåÂÜçÁîü„Åï„Çå„Åæ„Åô"
                  >
                    <NeomorphBox
                      width={SCREEN_WIDTH * 0.60}
                      height={60}
                    >
                      { 
                        isLoading ? (
                          // „É≠„Éº„Éá„Ç£„É≥„Ç∞‰∏≠„ÅØ ActivityIndicator „ÇíË°®Á§∫
                          <ActivityIndicator size="small" color="#000" style={styles.loadingIndicator} />
                        ) : (
                          <Text style={styles.playButtonText}>„Çø„ÉÉ„Éó„Åó„Å¶ËÅû„Åì„Åà„ÅüÂçòË™û„ÇíÂÖ•Âäõ</Text>
                        )
                      }
                    </NeomorphBox>
                  </TouchableOpacity>
                  )}
                </>
              ) : (
                <>
                  {/* „Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØÂÜÖÂÆπ„ÅÆ„ÅÜ„Å°„ÄÅÂÆüÈöõ„ÅÆ„ÄåÊ≠£Ëß£„Äç„Äå‰∏çÊ≠£Ëß£„Äç„ÅÆ„É©„Éô„É´„ÅØÂ§ñÈÉ®„Å´Âá∫„Åô„Åü„ÇÅ„ÄÅ„Åì„Åì„Åß„ÅØ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÇÑ„Åù„ÅÆ‰ªñ„ÅÆ„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØÊÉÖÂ†±„ÅÆ„Åø„ÇíË°®Á§∫ */}
                  {isAnswerCorrect && (
                    <View style={styles.lottieContainer}>
                      <LottieView
                        ref={confettiRef}
                        source={HanahubukiAnimation}
                        autoPlay={false}
                        loop={false}
                        style={styles.lottieStyle}
                        enableMergePathsAndroidForKitKatAndAbove
                      />
                    </View>
                  )}
                  <Text style={styles.feedbackText}>{risaltQuestion}</Text>
                  <Text style={styles.feedbackText}>{currentQuestion.correctAnswer}</Text>
                </>
              )}
            </View>
          </Animated.View>
        </NeomorphBox>


          {/* ÂõûÁ≠î„Çª„ÇØ„Ç∑„Éß„É≥ (Êú™ÂõûÁ≠îÊôÇ) */}
          {!isTransitioning && (
            <>
            <View style={styles.choicesMaxContainer}>
              {/* ÈÅ∏ÊäûËÇ¢ (count===0 or 1) */}
              {(correctCount === 0 || correctCount === 2) && (
                <View style={styles.choicesContainer}>
                  {shuffledChoices.map((choice, idx) => (
                    <TouchableOpacity
                      key={idx}
                      style={styles.choiceButton}
                      onPress={() => handleAnswer(choice)}
                    >
                      <NeomorphBox
                        width={SCREEN_WIDTH * 0.85}
                        height={60}
                      >
                        <Text style={styles.choiceText}>{choice}</Text>
                      </NeomorphBox>
                    </TouchableOpacity>
                  ))}
                </View>
              )}
            </View>

              {/* „ÉÜ„Ç≠„Çπ„ÉàÂÖ•Âäõ (count===1 or 7) */}
              {(correctCount === 1 || correctCount === 7) && (
            <View style={styles.absoluteInputContainer}>
              <View style={styles.inputRow}>
                <NeomorphBox width={SCREEN_WIDTH * 0.6} height={60}>
                <TextInput
                  style={styles.input}
                  value={userAnswer}
                  onChangeText={(text) => setUserAnswer(text)}
                  placeholder="Êó•Êú¨Ë™û„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ"
                  editable={true} // „Åì„Åì„ÇíÁ¢∫Ë™ç
                  returnKeyType="done"
                  onSubmitEditing={(event) => handleAnswer(event.nativeEvent.text)}
                />
                </NeomorphBox>

                <NeomorphBox width={80} height={60}> 
                  <TouchableOpacity
                    style={styles.submitButton}
                    onPress={() => handleAnswer()}
                  >
                    <Text style={styles.submitButtonText}>Á¢∫ÂÆö</Text>
                  </TouchableOpacity>
                </NeomorphBox>
              </View>
            </View>
              )}

            </>
          )}

            {showImage && 
            <>
            <NeomorphBox
              width={SCREEN_WIDTH * 0.85}
              height={SCREEN_WIDTH * 0.85 * (2 / 3)}
              style={styles.ImageBox}
            >
              <AnimatedRemoteImage
                imageData={imageData}
                width={SCREEN_WIDTH * 0.85}
                height={SCREEN_WIDTH * 0.85 * (2 / 3)}
              />
              </NeomorphBox>
            </>
            }
        </View>
        </ScrollView>

        {/* 1ÁßíÂæå„Å´Ë°®Á§∫„Åï„Çå„ÇãÊ¨°„Å∏„Éú„Çø„É≥ */}
        {/* Ê≠£Ëß£ÊôÇÔºöFSRSË©ï‰æ°4Êäû„Åæ„Åü„ÅØÊ¨°„Å∏„Éú„Çø„É≥„ÇíË°®Á§∫ */}
        {showNextButton && isAnswerCorrect && (
          shouldUpdateFSRS ? (
            // FSRS„ÇíÊõ¥Êñ∞„Åó„Å™„ÅÑÂ†¥Âêà„ÅØÊ¨°„Å∏„Éú„Çø„É≥„ÅÆ„Åø
            <View style={styles.nextButtonIncorrectContainer}>
              <TouchableOpacity
                onPressIn={() => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light)}
                onPress={() => handleNextQuestion(1)}
              >
                <NeomorphBox
                  width={SCREEN_WIDTH * 0.85}
                  height={60}
                >
                  <Text style={styles.nextButtonText}>Ê¨°„Å∏</Text>
                </NeomorphBox>
              </TouchableOpacity>
            </View>
          ) : (
            // ÈÄöÂ∏∏„ÅÆ4Ë©ï‰æ°„Éú„Çø„É≥
            <View style={styles.nextButtonContainer}>
              <View style={styles.nextButtonGrid}>
                {Array.from({ length: 4 }).map((_, idx) => (
                  <Animated.View key={idx} style={[styles.nextButtonGridItem, { opacity: fadeAnim }]}>
                    <TouchableOpacity
                      onPressIn={() => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light)}
                      onPress={() => handleNextQuestion(idx + 1)}
                      accessibilityLabel={`Âæ©ÁøíË©ï‰æ°„Éú„Çø„É≥Ôºö${nextButtonLabels[idx]}`}
                      accessibilityHint="„Çø„ÉÉ„Éó„Åô„Çã„Å®Ë©ï‰æ°„ÅåÈÅ©Áî®„Åï„Çå„Åæ„Åô"
                    >
                      <NeomorphBox
                        width={(SCREEN_WIDTH * 0.85) / 2 - 5}
                        height={60}
                      >
                        <Text style={styles.nextButtonText}>
                          {nextButtonLabels[idx]}
                        </Text>
                      </NeomorphBox>
                    </TouchableOpacity>
                  </Animated.View>
                ))}
              </View>
            </View>
          )
        )}
        {/* ‰∏çÊ≠£Ëß£ÊôÇÔºöNext „Éú„Çø„É≥„ÅÆ„ÅøË°®Á§∫ */}
        {showNextButton && isAnswerCorrect === false && (
          <View style={styles.nextButtonIncorrectContainer}>
            <TouchableOpacity
              onPressIn={() => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light)}
              onPress={() => handleNextQuestion(1)}
            >
              <NeomorphBox
                width={SCREEN_WIDTH * 0.85}
                height={60}
              >
                <Text style={styles.nextButtonText}>Ê¨°„Å∏</Text>
              </NeomorphBox>
            </TouchableOpacity>
          </View>
        )}
        {/* „Ç≠„Éº„Éú„Éº„Éâ (count===3,4,5,6,8) „ÅßË°®Á§∫ */}
        {showKeyboardExample && !isTransitioning && (
            <SafeAreaView style={styles.keyboardContainer}>
              <KeyboardExample onKeyPress={handleKeyPress} userAnswer={userAnswer}/>
            </SafeAreaView>
        )}
    </KeyboardAvoidingView>
  );
}

function createStyles(isDark) {
  // „ÉÜ„Éº„Éû„Å´Âøú„Åò„ÅüËâ≤„Çí‰∏ÄÂÖÉÁÆ°ÁêÜ
  const backgroundColor = isDark ? '#E3E5F2' : '#E3E5F2';
  const textColor       = isDark ? '#ccc'    : '#666';
  const questionColor   = isDark ? '#ddd'    : '#666';
  const buttonBg        = isDark ? '#444'    : '#6200ee';
  const buttonText      = isDark ? '#eee'    : '#666';
  const borderColor     = isDark ? '#888'    : '#777';

  const styles = StyleSheet.create({
  keyboardAvoidingView: {
    flex: 1,
    backgroundColor, 
  },
  lottieContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
  },
  Adcontainer:{
    zIndex:5,
    top:40
  },
  // LottieView Ëá™‰Ωì„ÅÆ„Çµ„Ç§„Ç∫ÊåáÂÆöÔºà‰æãÔºöÁîªÈù¢„ÅÆ50%„ÅÆÂπÖ„ÄÅÈ´ò„Åï„Å´„Åô„ÇãÔºâ
  lottieStyle: {
    width: '500%',
    height: '500%',
    // ËÉåÊôØËâ≤„ÇíÈô§Âéª„Åó„Å¶„ÄÅ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÅÆÂÜÖÂÆπ„ÅåË¶ã„Åà„Çã„Çà„ÅÜ„Å´„Åô„Çã
  },
  container: {
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 20,
    backgroundColor,
  },
  widgetsContainer: {
    justifyContent: 'flex-start',
    alignItems: 'center',
    paddingTop: 80,
    backgroundColor,
    width: '100%',
    height: 200, // ‰ªªÊÑè„ÅÆÈ´ò„Åï„Å´Ë™øÊï¥Ôºà‰æãÔºö200Ôºâ
  },
  neomorphBox: {
    position: 'absolute',
    top: 220,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 50,
    zIndex:3
  },  
  ImageBox: {
    position: 'absolute',
    top: 430,
    justifyContent: 'center',
    alignItems: 'center',
    zIndex:4,
  },
  questionSection: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 10,
  },
  translationText: {
    fontSize: 16,
    textAlign: 'center',
    marginBottom: 3,
    color: textColor,
  },
  questionText: {
    fontSize: 30,
    textAlign: 'center',
    marginVertical: 10,
    marginBottom:45,
    color: questionColor,
  },
  playButton: {
    backgroundColor: buttonBg,
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
    alignItems: 'center',
    width: '80%',
  },
  playButtonText: {
    color: buttonText,
    fontWeight: 'bold',
    fontSize: 16,
  },
  neomorphStyle1: {
    marginTop: 100,
  },
  choicesContainer: {
    position:'relative',
    width: '100%',
  },
  choicesMaxContainer:{
    flex: 1,
    justifyContent: 'flex-end', // Â≠êË¶ÅÁ¥†„Çí‰∏ãÈÉ®„Å´ÈÖçÁΩÆ
  },
  choiceButton: {
    padding: 5,
    borderRadius: 5,
    alignItems: 'center',
    marginBottom: 10,
  },
  choiceText: {
    color: buttonText,
    fontSize: 16,
    fontWeight: 'bold',
  },
  inputContainer: {
    alignItems: 'center',
    width: '90%',
    marginTop: 20,
  },
  inputRow: {
    flexDirection: 'row',
    // width: '100%',  // ÂøÖË¶Å„Å´Âøú„Åò„Å¶Ë™øÊï¥
    alignItems: 'center',
    justifyContent: 'center',
  },
  input: {
    flex: 1,
    height: 50,
    borderColor,
    borderRadius: 5,
    paddingHorizontal: 10,
    fontSize: 16,
    textAlign: 'center',
    color: textColor,
  },
  absoluteInputContainer: {
    position: 'absolute',
    top: 400,   // ‰ªªÊÑè„ÅÆÊï∞ÂÄ§„Å´Ë™øÊï¥
    alignItems: 'center',  // Ê®™ÊñπÂêë„ÅÆ‰∏≠Â§ÆÂØÑ„Åõ
    // justifyContent: 'center', // Á∏¶ÊñπÂêë„ÅÆÈÖçÁΩÆ„ÅØ‰∏çË¶Å„Å™„Çâ„Ç≥„É°„É≥„Éà„Ç¢„Ç¶„Éà
    zIndex: 3,          
  },
  submitButton: {
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderColor,
    borderRadius: 5,
  },
  submitButtonText: {
    color: textColor,
    fontWeight: 'bold',
    fontSize: 16,
  },
  keyboardContainer: {
    position: 'absolute',
    bottom: 10,
    paddingVertical: 10, // Remove vertical padding to eliminate gap
    paddingHorizontal: 20, // Add horizontal padding for left and right margins
    width: '100%',
},
  mLabelContainer: { 
    position: 'absolute',
    top: 130,
    zIndex: 1, // ‰ªñ„ÅÆË¶ÅÁ¥†„Çà„ÇäÂâçÈù¢„Å´Ë°®Á§∫„Åô„Çã
    // ÂøÖË¶Å„Å´Âøú„Åò„Å¶Ê®™ÊñπÂêë„ÅÆ‰∏≠Â§ÆÂØÑ„Åõ„Å™„Å©„ÇíËøΩÂä†
    alignItems: 'center',
    width: '100%',
  },
  greenBar: {
    position:'absolute',
    marginTop:350,
    height: 4, // Adjust the height as needed
    width: SCREEN_WIDTH * 0.7,
    backgroundColor: isDark ? 'rgba(0, 255, 191, 0.9)' : 'rgba(0, 239, 123, 0.5)',
    borderRadius: 5, // For rounded corners, adjust as needed
    marginBottom: 10, // Add some margin if necessary
    zIndex:4,
  },
  redBar: {
    position:'absolute',
    marginTop:350,
    height: 4, // Adjust the height as needed
    width: SCREEN_WIDTH * 0.7,
    backgroundColor: isDark ? 'rgba(255, 66, 66, 0.9)' : 'rgba(255, 66, 66, 0.5)',
    borderRadius: 5, // For rounded corners, adjust as needed
    marginBottom: 10, // Add some margin if necessary
    zIndex:4,
  },
  nullBar: {
    position:'absolute',
    marginTop:350,
    height: 4, // Adjust the height as needed
    width: SCREEN_WIDTH * 0.7,
    backgroundColor: 'rgba(114, 114, 114, 0.23)',
    borderRadius: 5, // For rounded corners, adjust as needed
    marginBottom: 10, // Add some margin if necessary
    zIndex:4,
  },
  feedbackText: {
    fontSize: 30,
    color: textColor,
    textAlign: 'center',
  },
  nextButtoncontainer:{
    flex: 1,
    backgroundColor,
    justifyContent: 'flex-end', // Â≠êË¶ÅÁ¥†„Çí‰∏ãÈÉ®„Å´ÈÖçÁΩÆ
  },
  // Êñ∞„Åó„ÅÑ nextButtonContainer „ÇíËøΩÂä†ÔºàÂ≠òÂú®„Åó„Å™„Åë„Çå„Å∞Ôºâ
  nextButtonContainer: {
    position: 'absolute',
    bottom: 0,
    width: '100%',
    backgroundColor, // „ÉÜ„Éº„ÉûÂØæÂøúÂ§âÊï∞
    paddingVertical: 10,
    alignItems: 'center',
  },
  nextButtoncontainer1:{
    flex: 1,
    backgroundColor,
    justifyContent: 'flex-end', // Â≠êË¶ÅÁ¥†„Çí‰∏ãÈÉ®„Å´ÈÖçÁΩÆ
    marginBottom:50,
    },
  nextButtonText: {
    color:textColor,
    fontWeight: 'bold',
    fontSize: 18,
    textAlign: 'center',
  },
  noQuestionsText: {
    fontSize: 18,
    textAlign: 'center',
    marginTop: 50,
    color: textColor,
  },
  animatedContainer: {
    width: '100%',
    alignItems: 'center',
  },
  nextButtonGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    marginHorizontal: '5%',
    marginTop: 10,
    paddingBottom: 20,
  },
  evalTitle: {
    fontSize: 16,
    marginBottom: 8,
    color: textColor,
    textAlign: 'center',
  },
  nextButtonGridItem: {
    width: '50%',
    marginBottom: 10,
  },
  // ‰∏çÊ≠£Ëß£ÊôÇ„ÅÆ‰∏ãÈÉ®Ë°®Á§∫Áî®„Çπ„Çø„Ç§„É´
nextButtonIncorrectContainer: {
  position: 'absolute',
  bottom: 50,        // ÁîªÈù¢‰∏ãÈÉ®„Å´ÈÖçÁΩÆ
  left: 0,
  right: 0,          // Ê®™ÂπÖ„ÅÑ„Å£„Å±„ÅÑ„Å´Â∫É„Åí„Å¶‰∏≠Â§ÆÊèÉ„Åà„ÇíÂäπ„Åã„Åõ„Çã
  alignItems: 'center',
},
  });
  return styles;
}
